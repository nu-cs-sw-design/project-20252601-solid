@startuml
package model {

    class Game {
        - numberOfPlayers: int
        - gameType: GameType
        - deck: Deck
        - players: Player[]
        - rand: Random
        - turnManager: TurnManager


        + Game(numberOfPlayers: int,
               gameType: GameType,
               deck: Deck,
               players: Player[],
               rand: Random)

        + startNewGame(gameType: GameType, numPlayers: int): void
        + getCurrentPlayer(): Player
        + getCurrentPlayerHand(): List<Card>
        + playCardAtIndex(index: int): void
        + endTurn(): void
        + isGameOver(): boolean

        + getNumberOfPlayers(): int
        + getGameType(): GameType
        + getDeck(): Deck
        + getPlayerAtIndex(playerIndex: int): Player
        + checkNumberOfAlivePlayers(): int
    }

    Game --> Deck
    Game --> TurnManager
    Game --> GameType


    class Deck{
        -deck: List<Card>
        -rand: Random
        -gameType: GameType
        -numberOfPlayers: int
        -maxDeckSize: int
        -instantiator: Instantiator

        -DECK_FULL_EXCEPTION: String
        -DRAW_FROM_EMPTY_DECK_EXCEPTION: String
        -NEGATIVE_INDEX_EXCEPTION: String
        -INDEX_GREATER_THAN_DECK_SIZE_EXCEPTION: String
        -MISMATCH_ORDER_SIZE_EXCEPTION: String
        -INDEX_OUT_OF_RANGE_EXCEPTION: String

        +Deck(deck: List<Card>, rand: Random,
              gameType: GameType, numberOfPlayers: int,
              maxDeckSize: int, instantiator: Instantiator)

        +getDeckSize(): int
        +getCardAtIndex(index: int): Card
        +initializeDeck(): void
        +shuffleDeck(): void
        +insertCard(cardType: CardType, numberOfCards: int, bottom: boolean): void
        +drawCard(): Card
        +drawCardFromBottom(): Card
        +setNumberOfPlayers(numberOfPlayers: int): void
        +chooseGameType(gameType: GameType): void
        +removeBombs(): int
        +insertExplodingKittenAtIndex(indexToInsert: int): void
        +insertImplodingKittenAtIndex(indexToInsert: int, card: Card): void

        #getCardTypeAtIndex(index: int): CardType

        +reorderDeckCards(newOrderIndices: int[], cardsToReorder: List<Card>): void

        -addedOutOfBounds(numberOfCards: int): boolean
        -checkIfExplodingKitten(index: int): boolean
        -checkIfIndexOutOfRange(index: int): boolean

        +peekTopCards(count: int): List<Card>

    }

    Deck --> CardType
    Deck --> GameType
    Deck --> Instantiator
    Deck --> " *" Card


    class Player {
        - playerID: int
        - hand: List<Card>
        - isDead: boolean
        - rand: Random
        - isCursed: boolean

        + Player(playerID: int, instantiator: Instantiator)

        + getPlayerID(): int
        + addDefuse(defuse: Card): void
        + addCardToHand(card: Card): void
        + hasCard(cardType: CardType): boolean
        + getHandSize(): int
        + getCardAt(index: int): Card
        + getIndexOfCard(cardType: CardType): int
        + removeCardFromHand(index: int): Card
        + shuffleHand(): void
        + checkNumberOfCardsInHand(cardType: CardType): int
        + getIsDead(): boolean
        + setIsDead(): void
        + getIsCursed(): boolean
        + setCursed(isCursed: boolean): void
        + getHand(): List<Card>
    }

    abstract class Card {
        - type: CardType

        + Card(type: CardType)
        + getType(): CardType
        + play(game: Game, currentPlayer: Player): void
    }

    class AttackCard extends Card {
        + AttackCard()
        + play(game: Game, currentPlayer: Player): void
    }

    class ShuffleCard extends Card {
        + ShuffleCard()
        + play(game: Game, currentPlayer: Player): void
    }

    class SeeTheFutureCard extends Card {
        + SeeTheFutureCard()
        + play(game: Game, currentPlayer: Player): void
    }

    class SkipCard extends Card {
        + SkipCard()
        + play(game: Game, currentPlayer: Player): void
    }

    Card --> CardType
    Card --> Game
    Card --> Player

    Card <|-- AttackCard
    Card <|-- ShuffleCard
    Card <|-- SeeTheFutureCard
    Card <|-- SkipCard



    class TurnManager {
        - currentPlayerTurn: int
        - currentPlayerNumberOfTurns: int
        - isReversed: boolean
        - attackQueue: List<Integer>
        - attackCounter: int
        - numberOfAttacks: int
        - turnTracker: int[]
        - attacked: boolean

        + TurnManager(numberOfPlayers: int)

        + getCurrentPlayerIndex(): int
        + getCurrentTurns(): int
        + startTurn(): void
        + endTurn(): void
        + applySkip(superSkip: boolean): void
        + queueAttack(targetPlayerIndex: int): void
        + processAttackQueue(): void
        + isAttackQueueEmpty(): boolean
    }


    Game --> " *" Player

    Player --> " *" Card
    Player --> CardType
    Player --> Instantiator


     class Instantiator {
         + createCard(cardType: CardType): Card
         + createRandom(): Random
         + createCardList(): List<Card>
     }

     enum GameType {
         NONE
         EXPLODING_KITTENS
         STREAKING_KITTENS
         IMPLODING_KITTENS
     }

     enum CardType {
         NOPE
         DEFUSE
         ATTACK
         SHUFFLE
         SKIP
         SEE_THE_FUTURE
         CAT_ONE
         CAT_TWO
         CAT_THREE
         CAT_FOUR
         EXPLODING_KITTEN
         STREAKING_KITTEN
         SWAP_TOP_AND_BOTTOM
         GARBAGE_COLLECTION
         CURSE_OF_THE_CAT_BUTT
         ALTER_THE_FUTURE
         CATOMIC_BOMB
         SUPER_SKIP
         MARK
         IMPLODING_KITTEN
         REVERSE
         FERAL_CAT
         TARGETED_ATTACK
         DRAW_FROM_THE_BOTTOM
     }

     Instantiator --> Card
     Instantiator --> CardType


package view {

    class GameUI {

        + chooseLanguage(): void
        + chooseGameType(): GameType
        + chooseNumberOfPlayers(): int

        + displayTurnStart(player: Player,
                           hand: List<Card>,
                           turns: int): void
        + promptPlaySpecialCombo(): boolean
        + promptPlayCardIndex(): int
        + promptEndTurn(): boolean

        + displaySeeTheFuture(cards: List<Card>): void
        + displayGameOver(winner: Player): void
        + displayError(message: String): void
    }
}


package controller {
    class GameController {
    }
}

class Main {
}

@enduml
