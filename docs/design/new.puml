@startuml
package model {

    +class Game {
        - numberOfPlayers: int
        - gameType: GameType
        - deck: Deck
        - players: Player[]
        - rand: Random
        - turnManager: TurnManager

        - DECK_FULL_EXCEPTION: String
        - DRAW_FROM_EMPTY_DECK_EXCEPTION: String
        - NEGATIVE_INDEX_EXCEPTION: String
        - INDEX_GREATER_THAN_DECK_SIZE_EXCEPTION: String
        - MISMATCH_ORDER_SIZE_EXCEPTION: String
        - INDEX_OUT_OF_RANGE_EXCEPTION: String

        + Game(numberOfPlayers: int,
               gameType: GameType,
               deck: Deck,
               players: Player[],
               rand: Random)

        + startNewGame(gameType: GameType, numPlayers: int): void
        + getCurrentPlayer(): Player
        + getCurrentPlayerHand(): List<Card>
        + playCardAtIndex(index: int): void
        + endTurn(): void
        + isGameOver(): boolean

        + getNumberOfPlayers(): int
        + getGameType(): GameType
        + getDeck(): Deck
        + getPlayerAtIndex(playerIndex: int): Player
        + checkNumberOfAlivePlayers(): int
    }

    Game --> Deck
    Game -->"*" Player
    Game --> TurnManager
    Game --> GameType


    +class Deck{
        -deck: List<Card>
        -rand: Random
        -gameType: GameType
        -numberOfPlayers: int
        -maxDeckSize: int
        -instantiator: Instantiator

        -DECK_FULL_EXCEPTION: String
        -DRAW_FROM_EMPTY_DECK_EXCEPTION: String
        -NEGATIVE_INDEX_EXCEPTION: String
        -INDEX_GREATER_THAN_DECK_SIZE_EXCEPTION: String
        -MISMATCH_ORDER_SIZE_EXCEPTION: String
        -INDEX_OUT_OF_RANGE_EXCEPTION: String

        +Deck(deck: List<Card>, rand: Random,
              gameType: GameType, numberOfPlayers: int,
              maxDeckSize: int, instantiator: Instantiator)

        +getDeckSize(): int
        +getCardAtIndex(index: int): Card
        +initializeDeck(): void
        +shuffleDeck(): void
        +insertCard(cardType: CardType, numberOfCards: int, bottom: boolean): void
        +drawCard(): Card
        +drawCardFromBottom(): Card
        +setNumberOfPlayers(numberOfPlayers: int): void
        +chooseGameType(gameType: GameType): void
        +removeBombs(): int
        +insertExplodingKittenAtIndex(indexToInsert: int): void
        +insertImplodingKittenAtIndex(indexToInsert: int, card: Card): void

        #getCardTypeAtIndex(index: int): CardType

        +reorderDeckCards(newOrderIndices: int[], cardsToReorder: List<Card>): void

        -addedOutOfBounds(numberOfCards: int): boolean
        -checkIfExplodingKitten(index: int): boolean
        -checkIfIndexOutOfRange(index: int): boolean

        +peekTopCards(count: int): List<Card>

    }

    Deck --> CardType
    Deck --> GameType
    Deck --> Instantiator
    Deck --> " *" Card


    class Player {
    }

    abstract class Card {
    }

    class TurnManager {
        - currentPlayerTurn: int
        - currentPlayerNumberOfTurns: int
        - isReversed: boolean
        - attackQueue: List<Integer>
        - attackCounter: int
        - numberOfAttacks: int
        - turnTracker: int[]
        - attacked: boolean
    }

    class Instantiator {
    }

    enum GameType {
    }

    enum CardType {
    }

    ' Cards to implement
    class AttackCard extends Card {
    }
    class ShuffleCard extends Card {
    }
    class SeeTheFutureCard extends Card {
    }
    class SkipCard extends Card {
    }
}

package view {
    class GameUI {
    }
}

package controller {
    class GameController {
    }
}

class Main {
}

@enduml
